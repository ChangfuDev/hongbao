# 数据一致性问题

经测试，在并发条件下抢红包，会导致库存的数量变成负数（这是高并发下的超发现象）


## 解决方案

### 悲观锁

也称独占锁，只能一个线程持有锁

利用数据库内部机制提供的锁，对更新的数据加锁

#### 实现
- 在SQL语句中加入 `for update`
    - 主键查询，会对行加锁
    - 如果使用非主键查询，要考虑是否对全表加锁的问题，加锁后可能会引发其他查询的阻塞

##### 缺点
- 性能不佳

### 乐观锁

一种不会阻塞其他线程的机制

#### 实现
- CAS原理
    - 加入版本号，防止ABA问题
    
    
##### 缺点
- 失败率有点高
    - 大量的版本号不一致导致

#### 乐观锁重入


为了避免高失败率，考虑在一定时间内允许重入

#### 实现

- 当因版本号原因失败后，重新尝试抢红包
    - 用一个时间戳判断是否重入，避免过多的SQL执行
    - 可以限定重入的次数，这样比利用时间戳还快一点

### 利用Redis
Redis中的Lua语言是原子性的，可以保证数据的一致性

#### 实现
1. 在Redis中缓存红包信息
2. 使用Lua语言编写业务逻辑
3. 红包库存为0时，异步批量同步数据过MySQL